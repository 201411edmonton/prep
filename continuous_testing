#!/usr/bin/env ruby

class ChangedFile
  attr_accessor :name,:last_changed_time

  def initialize(name)
    @name = name
    @last_changed_time = File.mtime(name)
    @was_changed = false
  end

  def has_changed?
    @last_changed_time < File.mtime(@name)
  end

  def update
    @last_changed_time = File.mtime(@name)
  end

  def was_deleted?
    not File.exists?(@name)
  end
end

all_files ={}

class BuildMessage
  def initialize(error_items)
    @error_items = error_items
  end

  def successful
    @error_items.length == 0
  end

  def message
    successful ? "Build Successful" : @error_items.join('\n')
  end
end


def populate_files(all_files)
  files_have_changed = false
  Dir.glob("**/*.cs").each do|file|
    unless (all_files.key?(file))
      files_have_changed = true
      all_files[file] = ChangedFile.new(file)
    end
  end
  files_have_changed
end

def remove_all_deleted(all_files)
  files_have_changed = false
  remove = {}
  all_files.each do |path,file|
    if (file.was_deleted?)
      remove[path] = file if file.was_deleted?
      files_have_changed = true
    end
  end
  remove.each do|path,file|
    all_files.delete(path)
  end
  files_have_changed
end

def changes_have_occured_in(all_files)
  return populate_files(all_files) | remove_all_deleted(all_files) |
    files_have_changed(all_files)
end

def files_have_changed(all_files)
  has_changed = false
  all_files.each do|path,file|
    has_changed |= file.has_changed?
    file.update
  end
  return has_changed
end

def get_errors_in(output)
  error_pattern = /error|FAIL/
  output.split("\n").select{|item| error_pattern =~ item}
end

def notify(build_message)
  icon = build_message.successful ? "green" : "red"
  `build/tools/growl/growlnotify.exe /t:"Build" /i:".\\#{icon}.jpg" "#{build_message.message.gsub("\n","\r\n")}"`
end

def monitor(all_files)
  if (changes_have_occured_in(all_files))
    errors = get_errors_in(`rake specs:run`)
    notify(BuildMessage.new(errors))
  end
end

while true do
  monitor(all_files)
  sleep(1)
end
